<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<!-- steal these colour values from JavaDocs; meh -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>Link.h</title>
</head>


<body>

<h1>Link.h</h1>

<ul>
	<li><a href = "#_declarations">Declarations</a></li>
	<li><a href = "#_summary">Function Summary</a></li>
	<li><a href = "#_detail">Function Detail</a></li>
</ul>

<p>
2017 Neil Edelman, distributed under the terms of the MIT License;
see readme.txt, or <a href = "https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>.
</p>
<p>
<em>&lt;T&gt;Link</em> stores doubly-linked-list(s) of <em>&lt;T&gt;LinkNode</em>, of which data of
type, <em>&lt;T&gt;</em>, must be set using <em>LINK_TYPE</em>. Supports one to four different
linked-list orders in the same type, <em>[A, D]</em>, set using <em>LINK_[A-D]_NAME</em>.
The preprocessor macros are all undefined at the end of the file for
convenience when including multiple <em>Link</em> types in the same file.
</p>
<p>
The <em>&lt;T&gt;LinkNode</em> storage is the responsibility of the caller. Specifically,
it does not have to be contiguous, and it can be nestled in multiple, possibly
different, structures. You can move (part) of the memory that is in an active
<em>Link</em> under some conditions, and still keep the integrity of the linked-list,
by <a href = "#&lt;T&gt;LinkMigrate">&lt;T&gt;LinkMigrate</a> or <a href = "#&lt;T&gt;LinkMigrateBlock">&lt;T&gt;LinkMigrateBlock</a>.
</p>
<dl>
	<dt>parameter: LINK_NAME, LINK_TYPE</dt>
	<dd>The name that literally becomes <em>&lt;T&gt;</em>, and a valid type associated therewith;
 should be conformant to naming and to the maximum available length of
 identifiers. Must each be present before including.</dd>
	<dt>parameter: LINK_[A-D]_NAME, LINK_[A-D]_COMPARATOR</dt>
	<dd>Each <em>LINK_[A-D]_NAME</em> literally becomes <em>&lt;L&gt;</em>. You can define an optional
 comparator, an equivalence relation function implementing <em>&lt;T&gt;Comparator</em>. For
 speed, it should be an inlined <em>static</em> function, if possible.</dd>
	<dt>parameter: LINK_TO_STRING</dt>
	<dd>Optional print function implementing <em>&lt;T&gt;ToString</em>; makes available
 <a href = "#&lt;T&gt;Link&lt;L&gt;ToString">&lt;T&gt;Link&lt;L&gt;ToString</a>.</dd>
	<dt>parameter: LINK_DYNAMIC_STORAGE</dt>
	<dd>This allocates <em>O(log n)</em> space needed for merge sort on the stack every time
 the List is sorted, instead of statically. This allows using the exact same
 sort on different data concurrently without crashing, but it consumes more
 resources.</dd>
	<dt>parameter: LINK_OPENMP</dt>
	<dd>Tries to parallelise using <em>OpenMP</em>, <a href = "http://www.openmp.org/">http://www.openmp.org/</a>.</dd>
	<dt>parameter: LINK_TEST</dt>
	<dd>Unit testing framework using <em>&lt;T&gt;LinkTest</em>, included in a separate header,
 <em>LinkTest.h</em>. Must be defined equal to a random filler, satisfying
 <em>&lt;T&gt;Action</em>. If <em>NDEBUG</em> is not defined, turns on <em>assert</em> private function
 integrity testing. Requires <em>LINK_TO_STRING</em>.</dd>
	<dt>minimum standard</dt>
	<dd>C89/90</dd>
	<dt>author</dt>
	<dd>Neil</dd>
	<dt>version</dt>
	<dd>1.0; 2017-05</dd>
	<dt>since</dt>
	<dd>1.0; 2017-05 separated from List.h</dd>
	<dt>fixme</dt>
	<dd><em>#pragma GCC diagnostic ignored "-Wconversion"</em>; version 4.2[.1] has a
 bug with <em>-Wconversion</em> that causes <em>assert</em> to emit a spurious warnings on
 <em>LINK_TEST</em>.</dd>
	<dt>fixme</dt>
	<dd><em>MSVC</em> mistakenly thinks it's: <em>Java</em>, <em>#pragma warning(disable: 4706)</em>;
 <em>C++11</em>, <em>#pragma warning(disable: 4996)</em>.
 4464 contains '..' thanks, we know
 4710 not inlined info
 4820 padding info
 4996 C++11</dd>
	<dt>fixme</dt>
	<dd><em>bcc</em>, <em>mingw</em>, <em>clang</em>, <em>etc</em>.</dd>
</dl>


<a name = "_declarations"><!-- --></a><h2>Declarations</h2>

<div><a name = "typedef void (*&lt;T&gt;Action)(T *const)"><!-- --></a>
<h3>typedef void (*&lt;T&gt;Action)(T *const)</h3>
<pre><b>typedef void (*&lt;T&gt;Action)(T *const)</b></pre>
<p>
Operates by side-effects only.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef int  (*&lt;T&gt;Predicate)(T *const, void *const)"><!-- --></a>
<h3>typedef int  (*&lt;T&gt;Predicate)(T *const, void *const)</h3>
<pre><b>typedef int  (*&lt;T&gt;Predicate)(T *const, void *const)</b></pre>
<p>
Passed <em>T</em> and <em>param</em>, (see <a href = "#&lt;T&gt;LinkSetParam">&lt;T&gt;LinkSetParam</a>,) returns (non-zero)
true or (zero) false.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef int  (*&lt;T&gt;Comparator)(const T *, const T *)"><!-- --></a>
<h3>typedef int  (*&lt;T&gt;Comparator)(const T *, const T *)</h3>
<pre><b>typedef int  (*&lt;T&gt;Comparator)(const T *, const T *)</b></pre>
<p>
Compares two values and returns less then, equal to, or greater then
zero. Should do so forming an equivalence relation with respect to <em>T</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*&lt;T&gt;ToString)(const T *const, char (*const)[12])"><!-- --></a>
<h3>typedef void (*&lt;T&gt;ToString)(const T *const, char (*const)[12])</h3>
<pre><b>typedef void (*&lt;T&gt;ToString)(const T *const, char (*const)[12])</b></pre>
<p>
Responsible for turning <em>&lt;T&gt;</em> (the first argument) into a 12 <em>char</em>
null-terminated output string (the second.)
</p>
<dl>
</dl>
</div>

<div><a name = "struct &lt;T&gt;LinkNode"><!-- --></a>
<h3>struct &lt;T&gt;LinkNode</h3>
<pre><b>struct &lt;T&gt;LinkNode</b></pre>
<p>
A single link in the linked-list derived from <em>&lt;T&gt;</em>. Storage of this
structure is the responsibility of the caller. A <em>&lt;T&gt;LinkNode</em> can be
reinterpreted (cast) to <em>&lt;T&gt;</em> as a single element; that is, <em>&lt;T&gt;</em> shall be the
first element of <em>&lt;T&gt;LinkNode</em>.
<pre>|    &lt;T&gt;LinkNode *node;
|    T *t;
|    for(node = &lt;T&gt;Link&lt;L&gt;GetFirst(link);
|        node;
|        node = &lt;T&gt;LinkNode&lt;L&gt;GetNext(node)) {
|        t = (T *)node;
|    }</pre> or
<pre>|    static void for_all_fn(T *const t) {
|        struct &lt;T&gt;LinkNode *const node = (struct &lt;T&gt;LinkNode *)t;
|    }</pre>
</p>
<dl>
</dl>
</div>

<div><a name = "struct &lt;T&gt;Link"><!-- --></a>
<h3>struct &lt;T&gt;Link</h3>
<pre><b>struct &lt;T&gt;Link</b></pre>
<p>
Serves as an a head for linked-list(s) of <em>&lt;T&gt;LinkNode</em>. No initialisation
is necessary when the variable is of <em>static</em> duration, otherwise use
<a href = "#&lt;T&gt;LinkClear">&lt;T&gt;LinkClear</a>.
</p>
<dl>
</dl>
</div>


<a name = "_summary"><!-- --></a><h2>Function Summary</h2>

<table>
<tr><th>Return Type</th><th>Function Name</th><th>Argument List</th></tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkClear">&lt;T&gt;LinkClear</a></td>
	<td>struct &lt;T&gt;Link *const this</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkAdd">&lt;T&gt;LinkAdd</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;LinkNode *const node</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkRemove">&lt;T&gt;LinkRemove</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;LinkNode *const node</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkTake">&lt;T&gt;LinkTake</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkMerge">&lt;T&gt;LinkMerge</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkSort">&lt;T&gt;LinkSort</a></td>
	<td>struct &lt;T&gt;Link *const this</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkSetParam">&lt;T&gt;LinkSetParam</a></td>
	<td>struct &lt;T&gt;Link *const this,
	void *const param</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkMigrate">&lt;T&gt;LinkMigrate</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;LinkNode *const node</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkMigrateBlock">&lt;T&gt;LinkMigrateBlock</a></td>
	<td>struct &lt;T&gt;Link *const this,
	void *const array, const size_t array_size, const void *const old_array</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;LinkNode *</td>
	<td><a href = "#&lt;T&gt;LinkNode&lt;L&gt;GetNext">&lt;T&gt;LinkNode&lt;L&gt;GetNext</a></td>
	<td>struct &lt;T&gt;LinkNode *const this</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;LinkNode *</td>
	<td><a href = "#&lt;T&gt;LinkNode&lt;L&gt;GetPrevious">&lt;T&gt;LinkNode&lt;L&gt;GetPrevious</a></td>
	<td>struct &lt;T&gt;LinkNode *const this</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;LinkNode *</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;GetFirst">&lt;T&gt;Link&lt;L&gt;GetFirst</a></td>
	<td>struct &lt;T&gt;Link *const this</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;LinkNode *</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;GetLast">&lt;T&gt;Link&lt;L&gt;GetLast</a></td>
	<td>struct &lt;T&gt;Link *const this</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;Sort">&lt;T&gt;Link&lt;L&gt;Sort</a></td>
	<td>struct &lt;T&gt;Link *const this</td>
</tr>
<tr>
	<td>static int</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;Compare">&lt;T&gt;Link&lt;L&gt;Compare</a></td>
	<td>const struct &lt;T&gt;Link *const this,
	const struct &lt;T&gt;Link *const that</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;TakeSubtraction">&lt;T&gt;Link&lt;L&gt;TakeSubtraction</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;TakeUnion">&lt;T&gt;Link&lt;L&gt;TakeUnion</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;TakeIntersection">&lt;T&gt;Link&lt;L&gt;TakeIntersection</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;TakeXor">&lt;T&gt;Link&lt;L&gt;TakeXor</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;TakeIf">&lt;T&gt;Link&lt;L&gt;TakeIf</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from, const &lt;T&gt;Predicate predicate</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;ForEach">&lt;T&gt;Link&lt;L&gt;ForEach</a></td>
	<td>struct &lt;T&gt;Link *const this,
	const &lt;T&gt;Action action</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;LinkNode *</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;ShortCircuit">&lt;T&gt;Link&lt;L&gt;ShortCircuit</a></td>
	<td>struct &lt;T&gt;Link *const this, const &lt;T&gt;Predicate predicate</td>
</tr>
<tr>
	<td>static char *</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;ToString">&lt;T&gt;Link&lt;L&gt;ToString</a></td>
	<td>const struct &lt;T&gt;Link *const this</td>
</tr>
</table>


<a name = "_detail"><!-- --></a><h2>Function Detail</h2>

<div><a name = "&lt;T&gt;LinkClear"><!-- --></a>
<h3>&lt;T&gt;LinkClear</h3>
<pre>static void <b>&lt;T&gt;LinkClear</b> (struct &lt;T&gt;Link *const this)</pre>
<p>
Clears all values from <em>this</em>, thereby initialising the <em>&lt;T&gt;Link</em>. If it
contained a list, those values are free.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkAdd"><!-- --></a>
<h3>&lt;T&gt;LinkAdd</h3>
<pre>static void <b>&lt;T&gt;LinkAdd</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;LinkNode *const node)</pre>
<p>
Sets the contents of <em>node</em> to push it to <em>this</em>, thereby initialising the
non-<em>&lt;T&gt;</em> parts of <em>&lt;T&gt;LinkNode</em>. Does not do any checks on <em>node</em> and
overwrites the data that was there. Specifically, it invokes undefined
behaviour to one add <em>node</em> to more than one list without removing it each
time. If either <em>this</em> or <em>node</em> is null, it does nothing.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkRemove"><!-- --></a>
<h3>&lt;T&gt;LinkRemove</h3>
<pre>static void <b>&lt;T&gt;LinkRemove</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;LinkNode *const node)</pre>
<p>
Removes <em>node</em> from the <em>this</em>. The <em>node</em> is now free to add to another
list. Removing an element that was not added to <em>this</em> results in undefined
behaviour. If either <em>this</em> or <em>node</em> is null, it does nothing.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkTake"><!-- --></a>
<h3>&lt;T&gt;LinkTake</h3>
<pre>static void <b>&lt;T&gt;LinkTake</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from)</pre>
<p>
Appends the elements of <em>from</em> onto <em>this</em>. If <em>this</em> is null, then it
removes elements. Unlike the <em>&lt;T&gt;Link&lt;L&gt;Take*</em>, where the elements are
re-ordered based on <em>&lt;L&gt;</em>, (they would not be in-place, otherwise,) this
function concatenates all the elements in each linked-list order.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkMerge"><!-- --></a>
<h3>&lt;T&gt;LinkMerge</h3>
<pre>static void <b>&lt;T&gt;LinkMerge</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from)</pre>
<p>
Merges the elements into <em>this</em> from <em>from</em> in (local) order; concatenates
all lists that don't have a <em>LINK_[A-D]_COMPARATOR</em>. If <em>this</em> is null, then
it removes elements.
</p>
<dl>
	<dt>order</dt>
	<dd>O(<em>this</em>.n + <em>from</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkSort"><!-- --></a>
<h3>&lt;T&gt;LinkSort</h3>
<pre>static void <b>&lt;T&gt;LinkSort</b> (struct &lt;T&gt;Link *const this)</pre>
<p>
Performs a stable, adaptive sort. If <em>LINK_OPENMP</em> is defined, then it will
try to parallelise; otherwise it is equivalent to calling <a href = "#&lt;T&gt;Link&lt;L&gt;Sort">&lt;T&gt;Link&lt;L&gt;Sort</a>
for all linked-lists with comparators. Requires one of <em>LINK_[A-D]_COMPARATOR</em>
be set.
</p>
<dl>
	<dt>order</dt>
	<dd>&Omega;(<em>this</em>.n), O(<em>this</em>.n log <em>this</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkSetParam"><!-- --></a>
<h3>&lt;T&gt;LinkSetParam</h3>
<pre>static void <b>&lt;T&gt;LinkSetParam</b> (struct &lt;T&gt;Link *const this,
	void *const param)</pre>
<p>
Sets the user-defined <em>param</em> of <em>this</em>.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkMigrate"><!-- --></a>
<h3>&lt;T&gt;LinkMigrate</h3>
<pre>static void <b>&lt;T&gt;LinkMigrate</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;LinkNode *const node)</pre>
<p>
Use when one <em>node</em> of <em>this</em> has switched places in memory. If <em>this</em> or
<em>node</em> is null, doesn't do anything.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkMigrateBlock"><!-- --></a>
<h3>&lt;T&gt;LinkMigrateBlock</h3>
<pre>static void <b>&lt;T&gt;LinkMigrateBlock</b> (struct &lt;T&gt;Link *const this,
	void *const array, const size_t array_size, const void *const old_array)</pre>
<p>
When <em>this</em> contains elements from an array of/containing <em>&lt;T&gt;LinkNode</em> in
memory that switched from <em>old_array</em> to <em>array</em> with byte-size <em>array_size</em>.
If <em>this</em>, <em>array</em>, or <em>old_array</em> is null, doesn't do anything.
</p>
<p>
Specifically, use when <em>this</em> is (partially) backed with an array that has
changed places due to a <em>realloc</em>.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(n)</dd>
	<dt>fixme</dt>
	<dd>Relies on not-strictly-defined behaviour because pointers are not
 necessarily contiguous in memory; it should be fine in practice.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkNode&lt;L&gt;GetNext"><!-- --></a>
<h3>&lt;T&gt;LinkNode&lt;L&gt;GetNext</h3>
<pre>static struct &lt;T&gt;LinkNode * <b>&lt;T&gt;LinkNode&lt;L&gt;GetNext</b> (struct &lt;T&gt;LinkNode *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>The next element after <em>this</em> in <em>&lt;L&gt;</em>. When <em>this</em> is the last
 element or when <em>this</em> is null, returns null.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkNode&lt;L&gt;GetPrevious"><!-- --></a>
<h3>&lt;T&gt;LinkNode&lt;L&gt;GetPrevious</h3>
<pre>static struct &lt;T&gt;LinkNode * <b>&lt;T&gt;LinkNode&lt;L&gt;GetPrevious</b> (struct &lt;T&gt;LinkNode *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>The previous element before <em>this</em> in <em>&lt;L&gt;</em>. When <em>this</em> is the
 first item or when <em>this</em> is null, returns null.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;GetFirst"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;GetFirst</h3>
<pre>static struct &lt;T&gt;LinkNode * <b>&lt;T&gt;Link&lt;L&gt;GetFirst</b> (struct &lt;T&gt;Link *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>A pointer to the first element of <em>this</em>.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;GetLast"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;GetLast</h3>
<pre>static struct &lt;T&gt;LinkNode * <b>&lt;T&gt;Link&lt;L&gt;GetLast</b> (struct &lt;T&gt;Link *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>A pointer to the last element of <em>this</em>.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;Sort"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;Sort</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;Sort</b> (struct &lt;T&gt;Link *const this)</pre>
<p>
Sorts <em>&lt;L&gt;</em>, but leaves the other lists in <em>&lt;T&gt;</em> alone. Must have
<em>LINK_[A-D]_COMPARATOR</em> defined.
</p>
<dl>
	<dt>order</dt>
	<dd>&Omega;(<em>this</em>.n), O(<em>this</em>.n log <em>this</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;Compare"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;Compare</h3>
<pre>static int <b>&lt;T&gt;Link&lt;L&gt;Compare</b> (const struct &lt;T&gt;Link *const this,
	const struct &lt;T&gt;Link *const that)</pre>
<p>
Compares two linked-lists as sequences in the order specified by <em>&lt;L&gt;</em>.
</p>
<dl>
	<dt>return</dt>
	<dd>The first comparator that is not equal to zero, or 0 if they are
 equal. Two null pointers are considered equal. Must have
 <em>LINK_[A-D]_COMPARATOR</em> defined.</dd>
	<dt>implements</dt>
	<dd>&lt;&lt;T&gt;Link&gt;Comparator</dd>
	<dt>order</dt>
	<dd>&Theta;(min(<em>this</em>.n, <em>that</em>.n))</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;TakeSubtraction"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;TakeSubtraction</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;TakeSubtraction</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b)</pre>
<p>
Appends <em>that</em> with <em>b</em> subtracted from <em>a</em> as a sequence in <em>&lt;L&gt;</em>. If
<em>this</em> is null, then it removes elements. Must have <em>LINK_[A-D]_COMPARATOR</em>
defined.
</p>
<dl>
	<dt>order</dt>
	<dd>O(<em>a</em>.n + <em>b</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;TakeUnion"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;TakeUnion</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;TakeUnion</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b)</pre>
<p>
Appends <em>this</em> with the union of <em>a</em> and <em>b</em> as a sequence in <em>&lt;L&gt;</em>. Equal
elements are moved from <em>a</em>. If <em>this</em> is null, then it removes elements. Must
have <em>LINK_[A-D]_COMPARATOR</em> defined.
</p>
<dl>
	<dt>order</dt>
	<dd>O(<em>a</em>.n + <em>b</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;TakeIntersection"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;TakeIntersection</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;TakeIntersection</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b)</pre>
<p>
Appends <em>this</em> with the intersection of <em>a</em> and <em>b</em> as a sequence in <em>&lt;L&gt;</em>.
Equal elements are moved from <em>a</em>. If <em>this</em> is null, then it removes elements.
Must have <em>LINK_[A-D]_COMPARATOR</em> defined.
</p>
<dl>
	<dt>order</dt>
	<dd>O(<em>a</em>.n + <em>b</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;TakeXor"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;TakeXor</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;TakeXor</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b)</pre>
<p>
Appends <em>this</em> with <em>a</em> exclusive-or <em>b</em> as a sequence in <em>&lt;L&gt;</em>. Equal
elements are moved from <em>a</em>. If <em>this</em> is null, then it removes elements. Must
have <em>LINK_[A-D]_COMPARATOR</em> defined.
</p>
<dl>
	<dt>order</dt>
	<dd>O(<em>a</em>.n + <em>b</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;TakeIf"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;TakeIf</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;TakeIf</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from, const &lt;T&gt;Predicate predicate)</pre>
<p>
Appends <em>this</em> with <em>from</em> if <em>predicate</em> is null or true in the order
specified by <em>&lt;L&gt;</em>. If <em>this</em> is null, then it removes elements.
</p>
<dl>
	<dt>order</dt>
	<dd>~ &Theta;(<em>this</em>.n) &times; O(<em>predicate</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;ForEach"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;ForEach</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;ForEach</b> (struct &lt;T&gt;Link *const this,
	const &lt;T&gt;Action action)</pre>
<p>
Performs <em>action</em> for each element in the list in the order specified by
<em>&lt;L&gt;</em>. For more flexibility, use <a href = "#&lt;T&gt;List&lt;L&gt;ShortCircuit">&lt;T&gt;List&lt;L&gt;ShortCircuit</a>, which takes a
<em>&lt;T&gt;Predicate</em>, and return true.
</p>
<dl>
	<dt>order</dt>
	<dd>~ &Theta;(<em>this</em>.n) &times; O(<em>action</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;ShortCircuit"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;ShortCircuit</h3>
<pre>static struct &lt;T&gt;LinkNode * <b>&lt;T&gt;Link&lt;L&gt;ShortCircuit</b> (struct &lt;T&gt;Link *const this, const &lt;T&gt;Predicate predicate)</pre>
<dl>
	<dt>return</dt>
	<dd>The first <em>&lt;T&gt;LinkNode</em> in the linked-list, ordered by <em>&lt;L&gt;</em>, that
 causes the <em>predicate</em> with <em>&lt;T&gt;</em> as argument to return false, or null if the
 <em>predicate</em> is true for every case. If <em>this</em> or <em>predicate</em> is null, returns
 null.</dd>
	<dt>order</dt>
	<dd>~ O(<em>this</em>.n) &times; O(<em>predicate</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;ToString"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;ToString</h3>
<pre>static char * <b>&lt;T&gt;Link&lt;L&gt;ToString</b> (const struct &lt;T&gt;Link *const this)</pre>
<p>
One can print 4 things at once before it overwrites. One must set
<em>LINK_TO_STRING</em> to a function implementing <em>&lt;T&gt;ToString</em> to get this
functionality.
</p>
<dl>
	<dt>return</dt>
	<dd>Prints the <em>this</em> in a static buffer.</dd>
	<dt>order</dt>
	<dd>&Theta;(1); it has a 255 character limit; every element takes some of it.</dd>
</dl>
</div>


</body>
</html>
