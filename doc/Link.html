<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<!-- steal these colour values from JavaDocs; meh -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>Link.h</title>
</head>


<body>

<h1>Link.h</h1>

<ul>
	<li><a href = "#_declarations">Declarations</a></li>
	<li><a href = "#_summary">Function Summary</a></li>
	<li><a href = "#_detail">Function Detail</a></li>
</ul>

<p>
2017 Neil Edelman, distributed under the terms of the MIT License;
see readme.txt, or <a href = "https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>.
</p>
<p>
<em>&lt;T&gt;Link</em> stores doubly-linked-list(s) of <em>&lt;T&gt;LinkNode</em>, of which data of
type, <em>&lt;T&gt;</em>, must be set using <em>LINK_TYPE</em>. The <em>&lt;T&gt;LinkNode</em> storage is the
resposibility of the caller. Specifically, it does not have to be contiguous,
and it can be nestled in multiple, possibly different, <em>struct</em>s. Supports one
to four different linked-list orders in the same type, <em>[A, D]</em>, set using
<em>LINK_[A-D]_NAME</em>. The preprocessor macros are all undefined at the end of the
file for convenience when including multiple Link types.
</p>
<dl>
	<dt>minimum standard</dt>
	<dd>C89/90</dd>
	<dt>author</dt>
	<dd>Neil</dd>
	<dt>version</dt>
	<dd>1.0; 2017-05</dd>
	<dt>since</dt>
	<dd>1.0; 2017-05 separated from List.h</dd>
	<dt>fixme</dt>
	<dd><em>#pragma GCC diagnostic ignored "-Wunused-function"</em>; short of manually
 selecting which functions, we can't do anything about it.</dd>
	<dt>fixme</dt>
	<dd><em>#pragma GCC diagnostic ignored "-Wconversion"</em>; version 4.2 has a bug
 with <em>-Wconversion</em> that causes <em>assert</em> to emit a spurious warnings on
 <em>LINK_TEST</em>.</dd>
	<dt>fixme</dt>
	<dd><em>#pragma warning(disable: 4706)</em>; <em>MSVC</em> mistakenly thinks it's <em>Java</em>.</dd>
	<dt>fixme</dt>
	<dd><em>#pragma warning(disable: 4996)</em>; <em>MSVC</em> mistakenly thinks it's <em>C++11</em>.</dd>
	<dt>fixme</dt>
	<dd><em>bcc</em>, <em>mingw</em>, <em>clang</em>, <em>etc</em>.</dd>
	<dt>fixme</dt>
	<dd>Code duplication natural merge and take merge.</dd>
	<dt>parameter: LINK_NAME, LINK_TYPE</dt>
	<dd>The name that becomes <em>T</em> and a valid type associated therewith (should be
 conformant to the maximum available length of identifiers.) Must each be
 present before including.</dd>
	<dt>parameter: LINK_[A-D]_NAME, LINK_[A-D]_COMPARATOR</dt>
	<dd>Each <em>LINK_[A-D]_NAME</em> becomes <em>L</em>. You can define an optional comparator, an
 equivalence relation function implementing <em>&lt;T&gt;Comparator</em>. For speed, it
 should be an inlined <em>static</em> function, if possible.</dd>
	<dt>parameter: LINK_TO_STRING</dt>
	<dd>Optional print function implementing <em>&lt;T&gt;ToString</em> and making available
 <a href = "#&lt;T&gt;Link&lt;L&gt;ToString">&lt;T&gt;Link&lt;L&gt;ToString</a>.</dd>
	<dt>parameter: LINK_DYNAMIC_STORAGE</dt>
	<dd>This allocates <em>O(log n)</em>, space needed for merge sort on the stack every time
 the List is sorted, instead of statically. This allows using the exact same
 sort on different data concurrently without crashing, but it consumes more
 resources.</dd>
	<dt>parameter: LINK_OPENMP</dt>
	<dd>Tries to parallelise using <em>OpenMP</em>, <a href = "http://www.openmp.org/">http://www.openmp.org/</a>.</dd>
	<dt>parameter: LINK_TEST</dt>
	<dd>Unit testing framework using <em>&lt;T&gt;LinkTest</em>, included in a separate header,
 <em>LinkTest.h</em>. Must be defined equal to a random filler, satisfying
 <em>&lt;T&gt;Action</em>. Also, turns on <em>assert</em> private function testing.</dd>
</dl>


<a name = "_declarations"><!-- --></a><h2>Declarations</h2>

<div><a name = "typedef void (*&lt;T&gt;Action)(T *const)"><!-- --></a>
<h3>typedef void (*&lt;T&gt;Action)(T *const)</h3>
<pre><b>typedef void (*&lt;T&gt;Action)(T *const)</b></pre>
<p>
Operates by side-effects only.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef int  (*&lt;T&gt;Predicate)(T *const, void *const)"><!-- --></a>
<h3>typedef int  (*&lt;T&gt;Predicate)(T *const, void *const)</h3>
<pre><b>typedef int  (*&lt;T&gt;Predicate)(T *const, void *const)</b></pre>
<p>
Passed <em>T</em> and <em>param</em>, returns (non-zero) true or (zero) false.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef int  (*&lt;T&gt;Comparator)(const T *, const T *)"><!-- --></a>
<h3>typedef int  (*&lt;T&gt;Comparator)(const T *, const T *)</h3>
<pre><b>typedef int  (*&lt;T&gt;Comparator)(const T *, const T *)</b></pre>
<p>
Compares two values and returns less then, equal to, or greater then
zero.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*&lt;T&gt;ToString)(const T *const, char (*const)[9])"><!-- --></a>
<h3>typedef void (*&lt;T&gt;ToString)(const T *const, char (*const)[9])</h3>
<pre><b>typedef void (*&lt;T&gt;ToString)(const T *const, char (*const)[9])</b></pre>
<p>
Responsible for turning <em>&lt;T&gt;</em> (the first argument) into a 9 <em>char</em>
null-terminated output string (the second.)
</p>
<dl>
</dl>
</div>

<div><a name = "struct &lt;T&gt;LinkNode"><!-- --></a>
<h3>struct &lt;T&gt;LinkNode</h3>
<pre><b>struct &lt;T&gt;LinkNode</b></pre>
<p>
A single link in the linked-list derived from <em>&lt;T&gt;</em>. Intended to be used
directly in <em>struct</em>s. <em>&lt;T&gt;</em> is the first element of <em>&lt;T&gt;LinkNode</em>, thus
casting is entirely safe.
</p>
<dl>
</dl>
</div>

<div><a name = "struct &lt;T&gt;Link"><!-- --></a>
<h3>struct &lt;T&gt;Link</h3>
<pre><b>struct &lt;T&gt;Link</b></pre>
<p>
Serves as an a head for linked-list(s) of <em>&lt;T&gt;LinkNode</em>. No initialisation
is necessary when the variable is of <em>static</em> duration, otherwise use
<a href = "#&lt;T&gt;LinkClear">&lt;T&gt;LinkClear</a>.
</p>
<dl>
</dl>
</div>


<a name = "_summary"><!-- --></a><h2>Function Summary</h2>

<table>
<tr><th>Return Type</th><th>Function Name</th><th>Argument List</th></tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkClear">&lt;T&gt;LinkClear</a></td>
	<td>struct &lt;T&gt;Link *const this</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkAdd">&lt;T&gt;LinkAdd</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;LinkNode *const node</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkRemove">&lt;T&gt;LinkRemove</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;LinkNode *const node</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkTake">&lt;T&gt;LinkTake</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkMerge">&lt;T&gt;LinkMerge</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkSort">&lt;T&gt;LinkSort</a></td>
	<td>struct &lt;T&gt;Link *const this</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkSetParam">&lt;T&gt;LinkSetParam</a></td>
	<td>struct &lt;T&gt;Link *const this,
	void *const param</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkMove">&lt;T&gt;LinkMove</a></td>
	<td>struct &lt;T&gt;Link *const this,
	const struct &lt;T&gt;LinkNode *const old, struct &lt;T&gt;LinkNode *const new</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;LinkBlockMove">&lt;T&gt;LinkBlockMove</a></td>
	<td>struct &lt;T&gt;Link *const this,
	const void *const old, const size_t byte_size, void *const new</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;LinkNode *</td>
	<td><a href = "#&lt;T&gt;LinkNode&lt;L&gt;GetNext">&lt;T&gt;LinkNode&lt;L&gt;GetNext</a></td>
	<td>struct &lt;T&gt;LinkNode *const this</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;LinkNode *</td>
	<td><a href = "#&lt;T&gt;LinkNode&lt;L&gt;GetPrevious">&lt;T&gt;LinkNode&lt;L&gt;GetPrevious</a></td>
	<td>struct &lt;T&gt;LinkNode *const this</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;LinkNode *</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;GetFirst">&lt;T&gt;Link&lt;L&gt;GetFirst</a></td>
	<td>struct &lt;T&gt;Link *const this</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;LinkNode *</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;GetLast">&lt;T&gt;Link&lt;L&gt;GetLast</a></td>
	<td>struct &lt;T&gt;Link *const this</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;Sort">&lt;T&gt;Link&lt;L&gt;Sort</a></td>
	<td>struct &lt;T&gt;Link *const this</td>
</tr>
<tr>
	<td>static int</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;Compare">&lt;T&gt;Link&lt;L&gt;Compare</a></td>
	<td>const struct &lt;T&gt;Link *const this,
	const struct &lt;T&gt;Link *const that</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;TakeSubtraction">&lt;T&gt;Link&lt;L&gt;TakeSubtraction</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;TakeUnion">&lt;T&gt;Link&lt;L&gt;TakeUnion</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;TakeIntersection">&lt;T&gt;Link&lt;L&gt;TakeIntersection</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;TakeXor">&lt;T&gt;Link&lt;L&gt;TakeXor</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;TakeIf">&lt;T&gt;Link&lt;L&gt;TakeIf</a></td>
	<td>struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from, const &lt;T&gt;Predicate predicate</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;ForEach">&lt;T&gt;Link&lt;L&gt;ForEach</a></td>
	<td>struct &lt;T&gt;Link *const this,
	const &lt;T&gt;Action action</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;LinkNode *</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;ShortCircuit">&lt;T&gt;Link&lt;L&gt;ShortCircuit</a></td>
	<td>struct &lt;T&gt;Link *const this, const &lt;T&gt;Predicate predicate</td>
</tr>
<tr>
	<td>static char *</td>
	<td><a href = "#&lt;T&gt;Link&lt;L&gt;ToString">&lt;T&gt;Link&lt;L&gt;ToString</a></td>
	<td>const struct &lt;T&gt;Link *const this</td>
</tr>
</table>


<a name = "_detail"><!-- --></a><h2>Function Detail</h2>

<div><a name = "&lt;T&gt;LinkClear"><!-- --></a>
<h3>&lt;T&gt;LinkClear</h3>
<pre>static void <b>&lt;T&gt;LinkClear</b> (struct &lt;T&gt;Link *const this)</pre>
<p>
Clears all values from <em>this</em>, thereby initialising the <em>&lt;T&gt;Link</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkAdd"><!-- --></a>
<h3>&lt;T&gt;LinkAdd</h3>
<pre>static void <b>&lt;T&gt;LinkAdd</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;LinkNode *const node)</pre>
<p>
Sets the contents of <em>node</em> to push it to <em>this</em>, thereby initialising the
non-<em>&lt;T&gt;</em> parts of <em>&lt;T&gt;LinkNode</em>. Does not do any checks on <em>node</em> and
overwrites the data that was there. Specifically, it invokes undefined
behaviour to one add <em>node</em> to more than one list without removing it each
time. If either <em>this</em> or <em>node</em> is null, it does nothing.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkRemove"><!-- --></a>
<h3>&lt;T&gt;LinkRemove</h3>
<pre>static void <b>&lt;T&gt;LinkRemove</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;LinkNode *const node)</pre>
<p>
Removes <em>node</em> from the <em>this</em>. The <em>node</em> is now free to add to another
list. Removing an element that was not added to <em>this</em> results in undefined
behaviour. If either <em>this</em> or <em>node</em> is null, it does nothing.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkTake"><!-- --></a>
<h3>&lt;T&gt;LinkTake</h3>
<pre>static void <b>&lt;T&gt;LinkTake</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from)</pre>
<p>
Appends the elements of <em>from</em> onto <em>this</em>. If <em>this</em> is null, then it
removes elements. <em>O(1)</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkMerge"><!-- --></a>
<h3>&lt;T&gt;LinkMerge</h3>
<pre>static void <b>&lt;T&gt;LinkMerge</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from)</pre>
<p>
Merges the elements into <em>this</em> from <em>from</em> in (local) order,
<em>O(this.n + from.n)</em>; concatenates all lists that don't have a
<em>LINK_[A-D]_COMPARATOR</em>. If <em>this</em> is null, then it removes elements.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkSort"><!-- --></a>
<h3>&lt;T&gt;LinkSort</h3>
<pre>static void <b>&lt;T&gt;LinkSort</b> (struct &lt;T&gt;Link *const this)</pre>
<p>
Sorts all by greedy natural insertion-merge sort. Like doing
<a href = "#&lt;T&gt;Link&lt;L&gt;Sort">&lt;T&gt;Link&lt;L&gt;Sort</a> for all lists in link with comparators. Designed to be
an <em>O(n log n)</em> sort that is adaptive and stable, it's not as good at sorting
random data as QuickSort.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkSetParam"><!-- --></a>
<h3>&lt;T&gt;LinkSetParam</h3>
<pre>static void <b>&lt;T&gt;LinkSetParam</b> (struct &lt;T&gt;Link *const this,
	void *const param)</pre>
<p>
Sets the user-defined <em>param</em> of <em>this</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkMove"><!-- --></a>
<h3>&lt;T&gt;LinkMove</h3>
<pre>static void <b>&lt;T&gt;LinkMove</b> (struct &lt;T&gt;Link *const this,
	const struct &lt;T&gt;LinkNode *const old, struct &lt;T&gt;LinkNode *const new)</pre>
<p>
Use when one <em>&lt;T&gt;LinkNode</em> of <em>this</em> has switched places in memory from
<em>old</em> to <em>new</em>. If <em>this</em>, <em>old</em>, or <em>new</em> is null, doesn't do anything.
<em>O(1)</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkBlockMove"><!-- --></a>
<h3>&lt;T&gt;LinkBlockMove</h3>
<pre>static void <b>&lt;T&gt;LinkBlockMove</b> (struct &lt;T&gt;Link *const this,
	const void *const old, const size_t byte_size, void *const new)</pre>
<p>
Use when <em>this</em> contains elements from an array of/containing <em>&lt;T&gt;LinkNode</em>
in memory that switched from <em>old</em> to <em>new</em> with byte-size <em>byte_size</em>. If
<em>this</em>, <em>old</em>, or <em>new</em> is null, doesn't do anything. For example, one must
call this on a <em>&lt;T&gt;Link</em> that is (partially) backed with an array that has
changed places due to a <em>realloc</em>. <em>O(n)</em>.
</p>
<p>
Relies on not-strictly-defined behaviour because pointers are not necessarily
contiguous in memory. It should be fine in practice.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkNode&lt;L&gt;GetNext"><!-- --></a>
<h3>&lt;T&gt;LinkNode&lt;L&gt;GetNext</h3>
<pre>static struct &lt;T&gt;LinkNode * <b>&lt;T&gt;LinkNode&lt;L&gt;GetNext</b> (struct &lt;T&gt;LinkNode *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>The next element after <em>this</em> in <em>&lt;L&gt;</em>. When <em>this</em> is the last
 element, returns null.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;LinkNode&lt;L&gt;GetPrevious"><!-- --></a>
<h3>&lt;T&gt;LinkNode&lt;L&gt;GetPrevious</h3>
<pre>static struct &lt;T&gt;LinkNode * <b>&lt;T&gt;LinkNode&lt;L&gt;GetPrevious</b> (struct &lt;T&gt;LinkNode *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>The previous element before <em>this</em> in <em>&lt;L&gt;</em>. When <em>this</em> is the
 first item, returns null.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;GetFirst"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;GetFirst</h3>
<pre>static struct &lt;T&gt;LinkNode * <b>&lt;T&gt;Link&lt;L&gt;GetFirst</b> (struct &lt;T&gt;Link *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>A pointer to the first element of <em>this</em>.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;GetLast"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;GetLast</h3>
<pre>static struct &lt;T&gt;LinkNode * <b>&lt;T&gt;Link&lt;L&gt;GetLast</b> (struct &lt;T&gt;Link *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>A pointer to the last element of <em>this</em>.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;Sort"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;Sort</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;Sort</b> (struct &lt;T&gt;Link *const this)</pre>
<p>
Sorts <em>&lt;L&gt;</em>, but leaves the other lists in <em>&lt;T&gt;</em> alone.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;Compare"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;Compare</h3>
<pre>static int <b>&lt;T&gt;Link&lt;L&gt;Compare</b> (const struct &lt;T&gt;Link *const this,
	const struct &lt;T&gt;Link *const that)</pre>
<p>
Compares two linked-lists as sequences in the order specified by <em>&lt;L&gt;</em>.
</p>
<dl>
	<dt>return</dt>
	<dd>The first comparator that is not equal to zero, or 0 if they are
 equal; if one list is a sub-list starting at the same point of the other,
 returns -1 or 1. Null pointers count as lists that are before every other
 list; two null pointers are considered equal.</dd>
	<dt>implements</dt>
	<dd>&lt;&lt;T&gt;Link&gt;Comparator</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;TakeSubtraction"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;TakeSubtraction</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;TakeSubtraction</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b)</pre>
<p>
Appends <em>that</em> with <em>b</em> subtracted from <em>a</em> as a sequence in <em>&lt;L&gt;</em>. If
<em>this</em> is null, then it removes elements.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;TakeUnion"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;TakeUnion</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;TakeUnion</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b)</pre>
<p>
Appends <em>this</em> with the union of <em>a</em> and <em>b</em> as a sequence in <em>&lt;L&gt;</em>. Equal
elements are moved from <em>a</em>. If <em>this</em> is null, then it removes elements.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;TakeIntersection"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;TakeIntersection</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;TakeIntersection</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b)</pre>
<p>
Appends <em>this</em> with the intersection of <em>a</em> and <em>b</em> as a sequence in <em>&lt;L&gt;</em>.
Equal elements are moved from <em>a</em>. If <em>this</em> is null, then it removes elements.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;TakeXor"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;TakeXor</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;TakeXor</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const a, struct &lt;T&gt;Link *const b)</pre>
<p>
Appends <em>this</em> with <em>a</em> exclusive-or <em>b</em> as a sequence in <em>&lt;L&gt;</em>. Equal
elements are moved from <em>a</em>. If <em>this</em> is null, then it removes elements.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;TakeIf"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;TakeIf</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;TakeIf</b> (struct &lt;T&gt;Link *const this,
	struct &lt;T&gt;Link *const from, const &lt;T&gt;Predicate predicate)</pre>
<p>
Appends <em>this</em> with <em>from</em> if <em>predicate</em> is null or true in the order
specified by <em>&lt;L&gt;</em>. If <em>this</em> is null, then it removes elements. The non-<em>&lt;L&gt;</em>
elements are forced to take the order of <em>&lt;L&gt;</em> in <em>this</em>; thus, copying to a
temporary list and re-ordering may be beneficial.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;ForEach"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;ForEach</h3>
<pre>static void <b>&lt;T&gt;Link&lt;L&gt;ForEach</b> (struct &lt;T&gt;Link *const this,
	const &lt;T&gt;Action action)</pre>
<p>
Performs <em>action</em> for each element in the list in the order specified by
<em>&lt;L&gt;</em>. For more flexibility, use <a href = "#&lt;T&gt;List&lt;L&gt;ShortCircuit">&lt;T&gt;List&lt;L&gt;ShortCircuit</a>, which takes a
<em>&lt;T&gt;Predicate</em>, and return true.
</p>
<dl>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;ShortCircuit"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;ShortCircuit</h3>
<pre>static struct &lt;T&gt;LinkNode * <b>&lt;T&gt;Link&lt;L&gt;ShortCircuit</b> (struct &lt;T&gt;Link *const this, const &lt;T&gt;Predicate predicate)</pre>
<dl>
	<dt>return</dt>
	<dd>The first <em>&lt;T&gt;LinkNode</em> in the linked-list, ordered by <em>&lt;L&gt;</em>, that
 causes the <em>predicate</em> with <em>&lt;T&gt;</em> as argument to return false, or null if the
 <em>predicate</em> is true for every case.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Link&lt;L&gt;ToString"><!-- --></a>
<h3>&lt;T&gt;Link&lt;L&gt;ToString</h3>
<pre>static char * <b>&lt;T&gt;Link&lt;L&gt;ToString</b> (const struct &lt;T&gt;Link *const this)</pre>
<p>
Prints the linked-list in a static buffer; one can print 4 things at once
before it overwrites. One must set <em>LINK_TO_STRING</em> to a function implementing
<em>&lt;T&gt;ToString</em> to get this functionality.
</p>
<dl>
</dl>
</div>


</body>
</html>
