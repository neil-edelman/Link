<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<!-- steal these colour values from JavaDocs; meh -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>List.h</title>
</head>


<body>

<h1>List.h</h1>

<ul>
	<li><a href = "#_declarations">Declarations</a></li>
	<li><a href = "#_summary">Function Summary</a></li>
	<li><a href = "#_detail">Function Detail</a></li>
</ul>

<p>
2017 Neil Edelman, distributed under the terms of the MIT License;
see readme.txt, or <a href = "https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>.
</p>
<p>
<em>&lt;T&gt;List</em> organises doubly-linked-list(s) of <em>&lt;T&gt;ListNode</em>, of which data of
type, <em>&lt;T&gt;</em>, must be set using <em>LIST_TYPE</em>. The <em>&lt;T&gt;ListNode</em> storage is the
responsibility of the caller; that means it can be nestled in multiple
structures. Supports one to four different orders in the same type, <em>[A, D]</em>,
set using <em>LIST_U[A-D]_NAME</em>. The preprocessor macros are all undefined at the
end of the file for convenience when including multiple <em>List</em> types in the
same file. Random <em>LIST_*</em> macros should be avoided.
</p>
<dl>
	<dt>parameter: LIST_NAME, LIST_TYPE</dt>
	<dd>The name that literally becomes <em>&lt;T&gt;</em>, and a valid type associated therewith;
 should be conformant to naming and to the maximum available length of
 identifiers. Must each be present before including.</dd>
	<dt>parameter: LIST_COMPARATOR or LIST_U[A-D]_NAME, LIST_U[A-D]_COMPARATOR</dt>
	<dd>Each <em>LIST_U[A-D]_NAME</em> literally becomes, <em>&lt;U&gt;</em>, an order. If you only need
 one order, you can skip it's name and define it anonymously, <em>&lt;U&gt;</em> will be
 empty. One can define an optional comparator, an equivalence relation function
 implementing <em>&lt;T&gt;Comparator</em>; <em>LIST_COMPARATOR</em> is used when you define the
 name anonymously.</dd>
	<dt>parameter: LIST_TO_STRING</dt>
	<dd>Optional print function implementing <em>&lt;T&gt;ToString</em>; makes available
 <a href = "#&lt;T&gt;List&lt;U&gt;ToString">&lt;T&gt;List&lt;U&gt;ToString</a>.</dd>
	<dt>parameter: LIST_STATIC_STORAGE</dt>
	<dd>This allocates <em>O(log max n)</em> space needed for merge sort statically, instead
 of stack every time the List is sorted. This does not allow it to sort data
 concurrently without crashing, but it consumes less space on the stack; about
 half-a-kilobyte, depending on <em>size_t</em>.</dd>
	<dt>parameter: LIST_OPENMP</dt>
	<dd>Tries to parallelise using <em>OpenMP</em>, <a href = "http://www.openmp.org/">http://www.openmp.org/</a>.</dd>
	<dt>parameter: LIST_TEST</dt>
	<dd>Unit testing framework using <em>&lt;T&gt;ListTest</em>, included in a separate header,
 <em>../test/ListTest.h</em>. Must be defined equal to a (random) filler, satisfying
 <em>&lt;T&gt;Action</em>. If <em>NDEBUG</em> is not defined, turns on <em>assert</em> private function
 integrity testing. Requires <em>LIST_TO_STRING</em>.</dd>
	<dt>minimum standard</dt>
	<dd>C89/90</dd>
	<dt>author</dt>
	<dd>Neil</dd>
	<dt>version</dt>
	<dd>1.2; 2017-07 made migrate simpler</dd>
	<dt>since</dt>
	<dd>1.1; 2017-06 split Add into Push and Unshift
			1.0; 2017-05 separated from List.h</dd>
	<dt>fixme</dt>
	<dd><em>GCC</em>: <em>#pragma GCC diagnostic ignored "-Wconversion"</em>; libc 4.2
 <em>assert</em> bug on <em>LIST_TEST</em>.</dd>
	<dt>fixme</dt>
	<dd><em>MSVC</em>: <em>#pragma warning(disable: x)</em> where <em>x</em> is: 4464 contains '..'
 uhm, thanks?; 4706 not <em>Java</em>; 4710, 4711 inlined info; 4820 padding info;
 4996 not <em>C++11</em>.</dd>
	<dt>fixme</dt>
	<dd><em>clang</em>: <em>#pragma clang diagnostic ignored "-Wx"</em> where <em>x</em> is:
 <em>padded</em>; <em>documentation</em>; <em>documentation-unknown-command</em> it's not quite
 <em>clang-tags</em>; 3.8 <em>disabled-macro-expansion</em> on <em>toupper</em> in <em>LIST_TEST</em>.</dd>
</dl>


<a name = "_declarations"><!-- --></a><h2>Declarations</h2>

<div><a name = "struct Migrate"><!-- --></a>
<h3>struct Migrate</h3>
<pre><b>struct Migrate</b></pre>
<p>
Contains information about a <em>realloc</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*Migrate)(void *const parent,
	const struct Migrate *const migrate)"><!-- --></a>
<h3>typedef void (*Migrate)(void *const parent,
	const struct Migrate *const migrate)</h3>
<pre><b>typedef void (*Migrate)(void *const parent,
	const struct Migrate *const migrate)</b></pre>
<p>
Function call on <em>realloc</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*&lt;T&gt;Action)(T *const)"><!-- --></a>
<h3>typedef void (*&lt;T&gt;Action)(T *const)</h3>
<pre><b>typedef void (*&lt;T&gt;Action)(T *const)</b></pre>
<p>
Operates by side-effects only.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*&lt;T&gt;BiAction)(T *const, void *const)"><!-- --></a>
<h3>typedef void (*&lt;T&gt;BiAction)(T *const, void *const)</h3>
<pre><b>typedef void (*&lt;T&gt;BiAction)(T *const, void *const)</b></pre>
<p>
Takes along a param.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef int  (*&lt;T&gt;Predicate)(T *const)"><!-- --></a>
<h3>typedef int  (*&lt;T&gt;Predicate)(T *const)</h3>
<pre><b>typedef int  (*&lt;T&gt;Predicate)(T *const)</b></pre>
<p>
Passed <em>T</em>, returns (non-zero) true or (zero) false.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef int (*&lt;T&gt;BiPredicate)(T *const, void *const)"><!-- --></a>
<h3>typedef int (*&lt;T&gt;BiPredicate)(T *const, void *const)</h3>
<pre><b>typedef int (*&lt;T&gt;BiPredicate)(T *const, void *const)</b></pre>
<p>
Passed <em>T</em> and a user-defined pointer value, returns (non-zero) true or
(zero) false.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef int  (*&lt;T&gt;Comparator)(const T *, const T *)"><!-- --></a>
<h3>typedef int  (*&lt;T&gt;Comparator)(const T *, const T *)</h3>
<pre><b>typedef int  (*&lt;T&gt;Comparator)(const T *, const T *)</b></pre>
<p>
Compares two values and returns less then, equal to, or greater then
zero. Should do so forming an equivalence relation with respect to <em>T</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*&lt;T&gt;ToString)(const T *const, char (*const)[12])"><!-- --></a>
<h3>typedef void (*&lt;T&gt;ToString)(const T *const, char (*const)[12])</h3>
<pre><b>typedef void (*&lt;T&gt;ToString)(const T *const, char (*const)[12])</b></pre>
<p>
Responsible for turning <em>&lt;T&gt;</em> (the first argument) into a 12 <em>char</em>
null-terminated output string (the second.)
</p>
<dl>
</dl>
</div>

<div><a name = "struct &lt;T&gt;ListNode"><!-- --></a>
<h3>struct &lt;T&gt;ListNode</h3>
<pre><b>struct &lt;T&gt;ListNode</b></pre>
<p>
A single link in the linked-list derived from <em>&lt;T&gt;</em>. Storage of this
structure is the responsibility of the caller. A <em>&lt;T&gt;ListNode</em> can be
reinterpreted (cast) to <em>&lt;T&gt;</em> as a single element; that is, <em>&lt;T&gt;</em> shall be the
first element of <em>&lt;T&gt;ListNode</em>.
<pre>|    &lt;T&gt;ListNode *node;
|    T *t;
|    for(t = &lt;T&gt;List&lt;U&gt;GetFirst(list);
|        t;
|        t = &lt;T&gt;Node&lt;U&gt;GetNext(node)) {
|    }</pre> or
<pre>|    static void for_all_fn(T *const t) {
|        struct &lt;T&gt;ListNode *const node = (struct &lt;T&gt;ListNode *)t;
|    }</pre>
</p>
<dl>
</dl>
</div>

<div><a name = "struct &lt;T&gt;List"><!-- --></a>
<h3>struct &lt;T&gt;List</h3>
<pre><b>struct &lt;T&gt;List</b></pre>
<p>
Serves as an a head for linked-list(s) of <em>&lt;T&gt;ListNode</em>. No initialisation
is necessary when the variable is of <em>static</em> duration, otherwise use
<a href = "#&lt;T&gt;ListClear">&lt;T&gt;ListClear</a>.
</p>
<dl>
</dl>
</div>


<a name = "_summary"><!-- --></a><h2>Function Summary</h2>

<table>
<tr><th>Return Type</th><th>Function Name</th><th>Argument List</th></tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;ListClear">&lt;T&gt;ListClear</a></td>
	<td>struct &lt;T&gt;List *const this</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;ListPush">&lt;T&gt;ListPush</a></td>
	<td>struct &lt;T&gt;List *const this,
	struct &lt;T&gt;ListNode *const node</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;ListUnshift">&lt;T&gt;ListUnshift</a></td>
	<td>struct &lt;T&gt;List *const this,
	struct &lt;T&gt;ListNode *const node</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;ListRemove">&lt;T&gt;ListRemove</a></td>
	<td>struct &lt;T&gt;List *const this, T *const data</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;ListTake">&lt;T&gt;ListTake</a></td>
	<td>struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const from</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;ListMerge">&lt;T&gt;ListMerge</a></td>
	<td>struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const from</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;ListSort">&lt;T&gt;ListSort</a></td>
	<td>struct &lt;T&gt;List *const this</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;ListMigrate">&lt;T&gt;ListMigrate</a></td>
	<td>void *const void_this,
	const struct Migrate *const migrate</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;Node&lt;U&gt;GetNext">&lt;T&gt;Node&lt;U&gt;GetNext</a></td>
	<td>T *const this</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;Node&lt;U&gt;GetPrevious">&lt;T&gt;Node&lt;U&gt;GetPrevious</a></td>
	<td>T *const this</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;GetFirst">&lt;T&gt;List&lt;U&gt;GetFirst</a></td>
	<td>struct &lt;T&gt;List *const this</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;GetLast">&lt;T&gt;List&lt;U&gt;GetLast</a></td>
	<td>struct &lt;T&gt;List *const this</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;Sort">&lt;T&gt;List&lt;U&gt;Sort</a></td>
	<td>struct &lt;T&gt;List *const this</td>
</tr>
<tr>
	<td>static int</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;Compare">&lt;T&gt;List&lt;U&gt;Compare</a></td>
	<td>const struct &lt;T&gt;List *const this,
	const struct &lt;T&gt;List *const that</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;TakeSubtraction">&lt;T&gt;List&lt;U&gt;TakeSubtraction</a></td>
	<td>struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const a, struct &lt;T&gt;List *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;TakeUnion">&lt;T&gt;List&lt;U&gt;TakeUnion</a></td>
	<td>struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const a, struct &lt;T&gt;List *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;TakeIntersection">&lt;T&gt;List&lt;U&gt;TakeIntersection</a></td>
	<td>struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const a, struct &lt;T&gt;List *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;TakeXor">&lt;T&gt;List&lt;U&gt;TakeXor</a></td>
	<td>struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const a, struct &lt;T&gt;List *const b</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;TakeIf">&lt;T&gt;List&lt;U&gt;TakeIf</a></td>
	<td>struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const from, const &lt;T&gt;Predicate predicate</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;BiTakeIf">&lt;T&gt;List&lt;U&gt;BiTakeIf</a></td>
	<td>struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const from, const &lt;T&gt;BiPredicate bipredicate,
	void *const param</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;ForEach">&lt;T&gt;List&lt;U&gt;ForEach</a></td>
	<td>struct &lt;T&gt;List *const this,
	const &lt;T&gt;Action action</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;BiForEach">&lt;T&gt;List&lt;U&gt;BiForEach</a></td>
	<td>struct &lt;T&gt;List *const this,
	const &lt;T&gt;BiAction biaction, void *const param</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;ShortCircuit">&lt;T&gt;List&lt;U&gt;ShortCircuit</a></td>
	<td>struct &lt;T&gt;List *const this, const &lt;T&gt;Predicate predicate</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;BiShortCircuit">&lt;T&gt;List&lt;U&gt;BiShortCircuit</a></td>
	<td>struct &lt;T&gt;List *const this,
	const &lt;T&gt;BiPredicate bipredicate, void *const param</td>
</tr>
<tr>
	<td>static char *</td>
	<td><a href = "#&lt;T&gt;List&lt;U&gt;ToString">&lt;T&gt;List&lt;U&gt;ToString</a></td>
	<td>const struct &lt;T&gt;List *const this</td>
</tr>
</table>


<a name = "_detail"><!-- --></a><h2>Function Detail</h2>

<div><a name = "&lt;T&gt;ListClear"><!-- --></a>
<h3>&lt;T&gt;ListClear</h3>
<pre>static void <b>&lt;T&gt;ListClear</b> (struct &lt;T&gt;List *const this)</pre>
<p>
Clears all values from <em>this</em>, thereby initialising the <em>&lt;T&gt;List</em>. If it
contained a list, those values are free.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;ListPush"><!-- --></a>
<h3>&lt;T&gt;ListPush</h3>
<pre>static void <b>&lt;T&gt;ListPush</b> (struct &lt;T&gt;List *const this,
	struct &lt;T&gt;ListNode *const node)</pre>
<p>
Sets the contents of <em>node</em> to add it to <em>this</em> at the end, thereby
initialising the non-<em>&lt;T&gt;</em> parts of <em>&lt;T&gt;ListNode</em>. Does not do any checks on
<em>node</em> and overwrites the data that was there. Specifically, it invokes
undefined behaviour to one add <em>node</em> to more than one list without removing
it each time. If either <em>this</em> or <em>node</em> is null, it does nothing.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;ListUnshift"><!-- --></a>
<h3>&lt;T&gt;ListUnshift</h3>
<pre>static void <b>&lt;T&gt;ListUnshift</b> (struct &lt;T&gt;List *const this,
	struct &lt;T&gt;ListNode *const node)</pre>
<p>
Sets the contents of <em>node</em> to add it to <em>this</em> at the beginning, thereby
initialising the non-<em>&lt;T&gt;</em> parts of <em>&lt;T&gt;ListNode</em>. Does not do any checks on
<em>node</em> and overwrites the data that was there. Specifically, it invokes
undefined behaviour to one add <em>node</em> to more than one list without removing
it each time. If either <em>this</em> or <em>node</em> is null, it does nothing.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;ListRemove"><!-- --></a>
<h3>&lt;T&gt;ListRemove</h3>
<pre>static void <b>&lt;T&gt;ListRemove</b> (struct &lt;T&gt;List *const this, T *const data)</pre>
<p>
Removes <em>data</em> from the <em>this</em>. The <em>data</em> is now free to add to another
list. Removing an element that was not added to <em>this</em> results in undefined
behaviour. If either <em>this</em> or <em>data</em> is null, it does nothing.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;ListTake"><!-- --></a>
<h3>&lt;T&gt;ListTake</h3>
<pre>static void <b>&lt;T&gt;ListTake</b> (struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const from)</pre>
<p>
Appends the elements of <em>from</em> onto <em>this</em>. If <em>this</em> is null, then it
removes elements. Unlike the <em>&lt;T&gt;List&lt;U&gt;Take*</em>, where the elements are
re-ordered based on <em>&lt;U&gt;</em>, (they would not be in-place, otherwise,) this
function concatenates all the elements in each linked-list order.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;ListMerge"><!-- --></a>
<h3>&lt;T&gt;ListMerge</h3>
<pre>static void <b>&lt;T&gt;ListMerge</b> (struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const from)</pre>
<p>
Merges the elements into <em>this</em> from <em>from</em> in (local) order; concatenates
all lists that don't have a <em>LIST_U[A-D]_COMPARATOR</em>. If <em>this</em> is null, then
it removes elements.
</p>
<dl>
	<dt>order</dt>
	<dd>O(<em>this</em>.n + <em>from</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;ListSort"><!-- --></a>
<h3>&lt;T&gt;ListSort</h3>
<pre>static void <b>&lt;T&gt;ListSort</b> (struct &lt;T&gt;List *const this)</pre>
<p>
Performs a stable, adaptive sort. If <em>LIST_OPENMP</em> is defined, then it will
try to parallelise; otherwise it is equivalent to calling <a href = "#&lt;T&gt;List&lt;U&gt;Sort">&lt;T&gt;List&lt;U&gt;Sort</a>
for all linked-lists with comparators. Requires one of <em>LIST_U[A-D]_COMPARATOR</em>
be set.
</p>
<dl>
	<dt>order</dt>
	<dd>&Omega;(<em>this</em>.n), O(<em>this</em>.n log <em>this</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;ListMigrate"><!-- --></a>
<h3>&lt;T&gt;ListMigrate</h3>
<pre>static void <b>&lt;T&gt;ListMigrate</b> (void *const void_this,
	const struct Migrate *const migrate)</pre>
<p>
Adjusts the pointers when supplied with a <em>Migrate</em> parameter, when <em>this</em>
contains <em>&lt;T&gt;ListNode</em> elements from memory that switched due to a <em>realloc</em>.
If <em>this</em> or <em>migrate</em> is null, doesn't do anything.
</p>
<dl>
	<dt>parameter: void_this</dt>
	<dd>A <em>struct &lt;T&gt;List *const</em> cast as <em>void *const</em> for
 implementing <em>Migrate</em>.</dd>
	<dt>parameter: migrate</dt>
	<dd>A <em>struct</em> coming from a <em>Migrate</em> function.</dd>
	<dt>implements</dt>
	<dd>Migrate</dd>
	<dt>order</dt>
	<dd>&Theta;(n)</dd>
	<dt>fixme</dt>
	<dd>Relies on not-strictly-defined behaviour because pointers are not
 necessarily contiguous in memory; it should be fine in practice.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Node&lt;U&gt;GetNext"><!-- --></a>
<h3>&lt;T&gt;Node&lt;U&gt;GetNext</h3>
<pre>static T * <b>&lt;T&gt;Node&lt;U&gt;GetNext</b> (T *const this)</pre>
<dl>
	<dt>parameter: this</dt>
	<dd>Must be in a <em>List</em> as a <em>&lt;T&gt;ListNode</em>.</dd>
	<dt>return</dt>
	<dd>The next element after <em>this</em> in <em>&lt;U&gt;</em>. When <em>this</em> is the last
 element or when <em>this</em> is null, returns null.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Node&lt;U&gt;GetPrevious"><!-- --></a>
<h3>&lt;T&gt;Node&lt;U&gt;GetPrevious</h3>
<pre>static T * <b>&lt;T&gt;Node&lt;U&gt;GetPrevious</b> (T *const this)</pre>
<dl>
	<dt>parameter: this</dt>
	<dd>Must be in a <em>List</em> as a <em>&lt;T&gt;ListNode</em>.</dd>
	<dt>return</dt>
	<dd>The previous element before <em>this</em> in <em>&lt;U&gt;</em>. When <em>this</em> is the
 first item or when <em>this</em> is null, returns null.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;GetFirst"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;GetFirst</h3>
<pre>static T * <b>&lt;T&gt;List&lt;U&gt;GetFirst</b> (struct &lt;T&gt;List *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>A pointer to the first element of <em>this</em>.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;GetLast"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;GetLast</h3>
<pre>static T * <b>&lt;T&gt;List&lt;U&gt;GetLast</b> (struct &lt;T&gt;List *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>A pointer to the last element of <em>this</em>.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;Sort"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;Sort</h3>
<pre>static void <b>&lt;T&gt;List&lt;U&gt;Sort</b> (struct &lt;T&gt;List *const this)</pre>
<p>
Sorts <em>&lt;U&gt;</em>, but leaves the other lists in <em>&lt;T&gt;</em> alone. Must have
<em>LIST_U[A-D]_COMPARATOR</em> defined.
</p>
<dl>
	<dt>order</dt>
	<dd>&Omega;(<em>this</em>.n), O(<em>this</em>.n log <em>this</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;Compare"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;Compare</h3>
<pre>static int <b>&lt;T&gt;List&lt;U&gt;Compare</b> (const struct &lt;T&gt;List *const this,
	const struct &lt;T&gt;List *const that)</pre>
<p>
Compares two linked-lists as sequences in the order specified by <em>&lt;U&gt;</em>.
</p>
<dl>
	<dt>return</dt>
	<dd>The first comparator that is not equal to zero, or 0 if they are
 equal. Two null pointers are considered equal. Must have
 <em>LIST_U[A-D]_COMPARATOR</em> defined.</dd>
	<dt>implements</dt>
	<dd>&lt;&lt;T&gt;List&gt;Comparator</dd>
	<dt>order</dt>
	<dd>&Theta;(min(<em>this</em>.n, <em>that</em>.n))</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;TakeSubtraction"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;TakeSubtraction</h3>
<pre>static void <b>&lt;T&gt;List&lt;U&gt;TakeSubtraction</b> (struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const a, struct &lt;T&gt;List *const b)</pre>
<p>
Appends <em>that</em> with <em>b</em> subtracted from <em>a</em> as a sequence in <em>&lt;U&gt;</em>. If
<em>this</em> is null, then it removes elements. Must have <em>LIST_U[A-D]_COMPARATOR</em>
defined.
</p>
<dl>
	<dt>order</dt>
	<dd>O(<em>a</em>.n + <em>b</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;TakeUnion"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;TakeUnion</h3>
<pre>static void <b>&lt;T&gt;List&lt;U&gt;TakeUnion</b> (struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const a, struct &lt;T&gt;List *const b)</pre>
<p>
Appends <em>this</em> with the union of <em>a</em> and <em>b</em> as a sequence in <em>&lt;U&gt;</em>. Equal
elements are moved from <em>a</em>. If <em>this</em> is null, then it removes elements. Must
have <em>LIST_U[A-D]_COMPARATOR</em> defined.
</p>
<dl>
	<dt>order</dt>
	<dd>O(<em>a</em>.n + <em>b</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;TakeIntersection"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;TakeIntersection</h3>
<pre>static void <b>&lt;T&gt;List&lt;U&gt;TakeIntersection</b> (struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const a, struct &lt;T&gt;List *const b)</pre>
<p>
Appends <em>this</em> with the intersection of <em>a</em> and <em>b</em> as a sequence in <em>&lt;U&gt;</em>.
Equal elements are moved from <em>a</em>. If <em>this</em> is null, then it removes elements.
Must have <em>LIST_U[A-D]_COMPARATOR</em> defined.
</p>
<dl>
	<dt>order</dt>
	<dd>O(<em>a</em>.n + <em>b</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;TakeXor"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;TakeXor</h3>
<pre>static void <b>&lt;T&gt;List&lt;U&gt;TakeXor</b> (struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const a, struct &lt;T&gt;List *const b)</pre>
<p>
Appends <em>this</em> with <em>a</em> exclusive-or <em>b</em> as a sequence in <em>&lt;U&gt;</em>. Equal
elements are moved from <em>a</em>. If <em>this</em> is null, then it removes elements. Must
have <em>LIST_U[A-D]_COMPARATOR</em> defined.
</p>
<dl>
	<dt>order</dt>
	<dd>O(<em>a</em>.n + <em>b</em>.n)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;TakeIf"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;TakeIf</h3>
<pre>static void <b>&lt;T&gt;List&lt;U&gt;TakeIf</b> (struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const from, const &lt;T&gt;Predicate predicate)</pre>
<p>
Appends <em>this</em> with <em>from</em> if <em>predicate</em> is null or true in the order
specified by <em>&lt;U&gt;</em>. If <em>this</em> is null, then it removes elements.
</p>
<dl>
	<dt>order</dt>
	<dd>~ &Theta;(<em>this</em>.n) &times; O(<em>predicate</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;BiTakeIf"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;BiTakeIf</h3>
<pre>static void <b>&lt;T&gt;List&lt;U&gt;BiTakeIf</b> (struct &lt;T&gt;List *const this,
	struct &lt;T&gt;List *const from, const &lt;T&gt;BiPredicate bipredicate,
	void *const param)</pre>
<p>
Appends <em>this</em> with <em>from</em> if <em>bipredicate</em> is null or true in the order
specified by <em>&lt;U&gt;</em>. If <em>this</em> is null, then it removes elements.
</p>
<dl>
	<dt>order</dt>
	<dd>~ &Theta;(<em>this</em>.n) &times; O(<em>predicate</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;ForEach"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;ForEach</h3>
<pre>static void <b>&lt;T&gt;List&lt;U&gt;ForEach</b> (struct &lt;T&gt;List *const this,
	const &lt;T&gt;Action action)</pre>
<p>
Performs <em>action</em> for each element in the list in the order specified by
<em>&lt;U&gt;</em>. You can tranfer or delete the data, or see <a href = "#&lt;T&gt;List&lt;U&gt;TakeIf">&lt;T&gt;List&lt;U&gt;TakeIf</a>.
</p>
<dl>
	<dt>order</dt>
	<dd>~ &Theta;(<em>this</em>.n) &times; O(<em>action</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;BiForEach"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;BiForEach</h3>
<pre>static void <b>&lt;T&gt;List&lt;U&gt;BiForEach</b> (struct &lt;T&gt;List *const this,
	const &lt;T&gt;BiAction biaction, void *const param)</pre>
<p>
Performs <em>biaction</em> for each element in the list in the order specified by
<em>&lt;U&gt;</em>.
</p>
<dl>
	<dt>order</dt>
	<dd>~ &Theta;(<em>this</em>.n) &times; O(<em>action</em>)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;ShortCircuit"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;ShortCircuit</h3>
<pre>static T * <b>&lt;T&gt;List&lt;U&gt;ShortCircuit</b> (struct &lt;T&gt;List *const this, const &lt;T&gt;Predicate predicate)</pre>
<dl>
	<dt>return</dt>
	<dd>The first <em>&lt;T&gt;</em> in the linked-list, ordered by <em>&lt;U&gt;</em>, that causes
 the <em>predicate</em> with <em>&lt;T&gt;</em> as argument to return false, or null if the
 <em>predicate</em> is true for every case. If <em>this</em> or <em>predicate</em> is null, returns
 null.</dd>
	<dt>order</dt>
	<dd>~ O(<em>this</em>.n) &times; O(<em>predicate</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;BiShortCircuit"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;BiShortCircuit</h3>
<pre>static T * <b>&lt;T&gt;List&lt;U&gt;BiShortCircuit</b> (struct &lt;T&gt;List *const this,
	const &lt;T&gt;BiPredicate bipredicate, void *const param)</pre>
<dl>
	<dt>return</dt>
	<dd>The first <em>&lt;T&gt;</em> in the linked-list, ordered by <em>&lt;U&gt;</em>, that
 causes the <em>bipredicate</em> with <em>&lt;T&gt;</em> and <em>param</em> as arguments to return false,
 or null if the <em>bipredicate</em> is true for every case. If <em>this</em> or
 <em>bipredicate</em> is null, returns null.</dd>
	<dt>order</dt>
	<dd>~ O(<em>this</em>.n) &times; O(<em>predicate</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;List&lt;U&gt;ToString"><!-- --></a>
<h3>&lt;T&gt;List&lt;U&gt;ToString</h3>
<pre>static char * <b>&lt;T&gt;List&lt;U&gt;ToString</b> (const struct &lt;T&gt;List *const this)</pre>
<p>
Can print 4 things at once before it overwrites. One must set
<em>LIST_TO_STRING</em> to a function implementing <em>&lt;T&gt;ToString</em> to get this
functionality.
</p>
<dl>
	<dt>return</dt>
	<dd>Prints the <em>this</em> in a static buffer.</dd>
	<dt>order</dt>
	<dd>&Theta;(1); it has a 255 character limit; every element takes some of it.</dd>
</dl>
</div>


</body>
</html>
