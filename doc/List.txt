# List.h #

2017 Neil Edelman, distributed under the terms of the MIT License;
 see readme.txt, or [ https://opensource.org/licenses/MIT ].

 _<T>List_ organises doubly-linked-list(s) of _<T>ListNode_, (not plain _<T>_,)
 of which data of type, _<T>_, must be set using _LIST_TYPE_. The _<T>ListNode_
 storage is the responsibility of the caller; that means it can be nestled in
 multiple polymorphic structures. Supports one to four different orders in the
 same type. The preprocessor macros are all undefined at the end of the file
 for convenience when including multiple _List_ types in the same file. Random
 _LIST_*_ macros should be avoided.

parameter: LIST_NAME, LIST_TYPE -- The name that literally becomes _<T>_, and a valid type associated therewith;
 should be conformant to naming and to the maximum available length of
 identifiers. Must each be present before including.

parameter: LIST_COMPARATOR or LIST_U[A-D]_NAME, LIST_U[A-D]_COMPARATOR -- Each _LIST_U[A-D]_NAME_ literally becomes, _<U>_, an order, and optional
 comparator, _LIST_U[A-D]_COMPARATOR_, an equivalence relation function
 implementing _<T>Comparator_. Not defining this implies one anonymous order
 which one can set a comparator using _LIST_COMPARATOR_; _<U>_ will be empty in
 this case.

parameter: LIST_TO_STRING -- Optional print function implementing _<T>ToString_; makes available
 `<T>List<U>ToString`.

parameter: LIST_OPENMP -- Tries to parallelise using _OpenMP_, [ http://www.openmp.org/ ]. This is
 limited to some, usually multi-order, functions.

parameter: LIST_TEST -- Unit testing framework using _<T>ListTest_, included in a separate header,
 _../test/ListTest.h_. Must be defined equal to a (random) filler, satisfying
 _<T>Action_. If _NDEBUG_ is not defined, turns on _assert_ private function
 integrity testing. Requires _LIST_TO_STRING_.

parameter: NDEBUG -- Uses standard assertions, so turning this on will speed up the code.

minimum standard: C89/90

author: Neil

version: 2018-02 Eliminated the need for unnecessarily _<T>List_.
			Now you must initialise static variables with _<T>ListClear_.
			Eliminated _LIST_STATIC_SORT_.

since: 2017-12 Type information on backing.
			2017-10 Anonymous orders.
			2017-07 Made migrate simpler.
			2017-06 Split Add into Push and Unshift.
			2017-05 Separated from backing.

fixme: _GCC_: _#pragma GCC diagnostic ignored "-Wconversion"_; libc 4.2
 _assert_ bug on _LIST_TEST_.

fixme: _MSVC_: _#pragma warning(disable: x)_ where _x_ is: 4464 contains '..'
 uhm, thanks?; 4706 not _Java_; 4710, 4711 inlined info; 4820 padding info;
 4996 not _C++11_.

fixme: _clang_: _#pragma clang diagnostic ignored "-Wx"_ where _x_ is:
 _padded_; _documentation_; _documentation-unknown-command_ it's not quite
 _clang-tags_; 3.8 _disabled-macro-expansion_ on _toupper_ in _LIST_TEST_.

fixme: We are on the fence about whether the insertion functions should take
 _T_ or _<T>ListNode_. Yes, you always have to have a node, _<T>ListNode_ is
 safer, otoh, if you remove something you can't add without casting. Also this
 is the only place where we use it, so it's un-symmetric.



## Declarations ##

### struct Migrate ###

struct Migrate

Contains information about a _realloc_.


### struct <T>ListNode ###

struct <T>ListNode

A single link in the linked-list derived from _<T>_. Storage of this
 structure is the responsibility of the caller. The _<T>_ is stored in the
 element _data_.


### struct <T>List ###

struct <T>List

Serves as an a head for linked-list(s) of _<T>ListNode_. Use
 `<T>ListClear` to initialise.


### typedef void (*<T>ListMigrateElement)(T *const element,
	const struct Migrate *const migrate) ###

typedef void (*<T>ListMigrateElement)(T *const element,
	const struct Migrate *const migrate)

Calls `<T>ListMigratePointer`, given to `<T>List<U>MigrateEach`, in
 the handler for the _Migrate_.


### typedef void (*<T>Action)(T *const) ###

typedef void (*<T>Action)(T *const)

Takes _<T>_; used in `<T>List<U>ForEach`.


### typedef void (*<T>BiAction)(T *const, void *const) ###

typedef void (*<T>BiAction)(T *const, void *const)

Takes _<T>_ and <void *>; used in `<T>List<U>BiForEach`.


### typedef int (*<T>Predicate)(const T *const) ###

typedef int (*<T>Predicate)(const T *const)

Takes _<T>_, returns (non-zero) true or (zero) false.


### typedef int (*<T>BiPredicate)(T *const, void *const) ###

typedef int (*<T>BiPredicate)(T *const, void *const)

Takes _<T>_ and _void *_, returns (non-zero) true or (zero) false.


### typedef int (*<T>Comparator)(const T *, const T *) ###

typedef int (*<T>Comparator)(const T *, const T *)

Compares two _<T>_ values and returns less then, equal to, or greater then
 zero. Should do so forming an equivalence relation with respect to _<T>_.


### typedef void (*<T>ToString)(const T *const, char (*const)[12]) ###

typedef void (*<T>ToString)(const T *const, char (*const)[12])

Responsible for turning _<T>_ (the first argument) into a 12 _char_
 null-terminated output string (the second.)




## Function Summary ##

_Return Type_	_Function Name_	_Argument List_
static void	<T>ListClear	(struct <T>List *const list)
static void	<T>ListPush	(struct <T>List *const list, T *const data)
static void	<T>ListUnshift	(struct <T>List *const list, T *const data)
static void	<T>ListRemove	(T *const data)
static void	<T>ListTake	(struct <T>List *const list,
	struct <T>List *const from)
static void	<T>ListTakeBefore	(T *const data, struct <T>List *const from)
static void	<T>ListMerge	(struct <T>List *const list,
	struct <T>List *const from)
static void	<T>ListSort	(struct <T>List *const list)
static void	<T>ListMigrate	(struct <T>List *const list,
	const struct Migrate *const migrate)
static void	<T>MigratePointer	(T **const t_ptr,
	const struct Migrate *const migrate)
static void	<T>List<U>MigrateEach	(struct <T>List *const list,
	const <T>ListMigrateElement handler, const struct Migrate *const migrate)
static T *	<T>List<U>GetNext	(T *const data)
static T *	<T>List<U>GetPrevious	(T *const data)
static T *	<T>List<U>GetFirst	(struct <T>List *const list)
static T *	<T>List<U>GetLast	(struct <T>List *const list)
static void	<T>List<U>Sort	(struct <T>List *const list)
static int	<T>List<U>Compare	(const struct <T>List *const alist,
	const struct <T>List *const blist)
static void	<T>List<U>TakeSubtraction	(struct <T>List *const list,
	struct <T>List *const a, struct <T>List *const b)
static void	<T>List<U>TakeUnion	(struct <T>List *const list,
	struct <T>List *const a, struct <T>List *const b)
static void	<T>List<U>TakeIntersection	(struct <T>List *const list,
	struct <T>List *const a, struct <T>List *const b)
static void	<T>List<U>TakeXor	(struct <T>List *const list,
	struct <T>List *const a, struct <T>List *const b)
static void	<T>List<U>TakeIf	(struct <T>List *const list,
	struct <T>List *const from, const <T>Predicate predicate)
static void	<T>List<U>BiTakeIf	(struct <T>List *const list,
	struct <T>List *const from, const <T>BiPredicate bipredicate,
	void *const param)
static void	<T>List<U>ForEach	(struct <T>List *const list,
	const <T>Action action)
static void	<T>List<U>BiForEach	(struct <T>List *const list,
	const <T>BiAction biaction, void *const param)
static T *	<T>List<U>ShortCircuit	(struct <T>List *const list,
	const <T>Predicate predicate)
static T *	<T>List<U>BiShortCircuit	(struct <T>List *const list,
	const <T>BiPredicate bipredicate, void *const param)
static char *	<T>List<U>ToString	(const struct <T>List *const list)



## Function Detail ##

### <T>ListClear ###

static void <T>ListClear(struct <T>List *const list)

Clears and removes all values from _list_, thereby initialising the
 _<T>List_.

order: \Theta(1)



### <T>ListPush ###

static void <T>ListPush(struct <T>List *const list, T *const data)

Initialises the contents of the node which contains _data_ to add it to the
 end of _list_. If either _list_ or _data_ is null, it does nothing.

parameter: data -- Must be inside of a _<T>ListNode_ and not associated to any list;
 this associates the _<T>ListNode_ with the list until it is removed, see, for
 example, `<T>ListRemove`.

order: \Theta(1)



### <T>ListUnshift ###

static void <T>ListUnshift(struct <T>List *const list, T *const data)

Initialises the contents of the node which contains _data_ to add it to the
 beginning of _list_. If either _list_ or _data_ is null, it does nothing.

parameter: node -- Must be inside of a _<T>ListNode_ and not associated to any list;
 this associates the _<T>ListNode_ with the list until it is removed, see, for
 example, `<T>ListRemove`.

order: \Theta(1)

fixme: Untested.



### <T>ListRemove ###

static void <T>ListRemove(T *const data)

Removes _data_ from the list. The _data_ is now free to add to another
 list. Removing an element that was not added to a list results in undefined
 behaviour. If _data_ is null, it does nothing.

order: \Theta(1)



### <T>ListTake ###

static void <T>ListTake(struct <T>List *const list,
	struct <T>List *const from)

Appends the elements of _from_ onto _list_. If _list_ is null, then it
 removes elements. Unlike `<T>List<U>TakeIf` and all other selective
 choosing functions, this function preserves two or more orders.

order: \Theta(1)



### <T>ListTakeBefore ###

static void <T>ListTakeBefore(T *const data, struct <T>List *const from)

Appends the elements from _from_ before _data_. If _data_ or _from_
 is null, doesn't do anything. If _data_ is not part of a valid list, results
 are undefined. The _from_ list will be empty at the end.

order: \Theta(1)

fixme: Untested.



### <T>ListMerge ###

static void <T>ListMerge(struct <T>List *const list,
	struct <T>List *const from)

Merges the elements into _list_ from _from_ in, (local, it doesn't sort
 them first, see `<T>ListSort`,) order; concatenates all lists that don't
 have a _LIST_U[A-D]_COMPARATOR_. If _list_ is null, then it removes elements.

order: O(_list_.n + _from_.n)



### <T>ListSort ###

static void <T>ListSort(struct <T>List *const list)

Performs a stable, adaptive sort on all orders which have comparators.

order: \Omega(_list_.n), O(_list_.n log _list_.n)



### <T>ListMigrate ###

static void <T>ListMigrate(struct <T>List *const list,
	const struct Migrate *const migrate)

Adjusts the pointers internal to the _<T>List_ when supplied with a
 _Migrate_ parameter, when _list_ contains _<T>ListNode_ elements from memory
 that switched due to a _realloc_. If _list_ or _migrate_ is null, doesn't do
 anything.

parameter: migrate -- Should only be called in a _Migrate_ function; pass the
 _migrate_ parameter.

implements: <T>Migrate

order: \Theta(n)

fixme: Relies on not-strictly-defined behaviour because pointers are not
 necessarily contiguous in memory; it should be fine in practice.



### <T>MigratePointer ###

static void <T>MigratePointer(T **const t_ptr,
	const struct Migrate *const migrate)

Use this inside the function that is passed to `<T>List<U>MigrateEach`
 to fix reallocated pointers. It doesn't affect pointers not in the _realloc_ed
 region. To update the underlying list, see `<T>ListMigrate`.

fixme: Untested.



### <T>List<U>MigrateEach ###

static void <T>List<U>MigrateEach(struct <T>List *const list,
	const <T>ListMigrateElement handler, const struct Migrate *const migrate)

Calls _handler_ on every element that is part of the list. This allows
 _<T>_ elements in the list to contain pointers to moving structures due to a
 _realloc_, using the sub-types's _Migrate_ function. If _list_, _handler_, or
 _migrate_ is null, doesn't do anything.

parameter: handler -- Has the responsibility of calling `<T>ListMigratePointer`
 on all pointers affected by the _realloc_ of this handler.

order: \Theta(n)



### <T>List<U>GetNext ###

static T * <T>List<U>GetNext(T *const data)



parameter: data -- Must be part of a _List_. If _data_ is not part of a valid
 list or has migrated locations due to a backing _realloc_, this function is
 undefined.

return: The next element in _<U>_. When _data_ is the last element, returns
 null.

order: \Theta(1)



### <T>List<U>GetPrevious ###

static T * <T>List<U>GetPrevious(T *const data)



parameter: data -- Must be part of a _List_. If _data_ is not part of a valid
 list or has migrated locations due to a backing _realloc_, this function is
 undefined.

return: The previous element in _<U>_. When _data_ is the first element,
 returns null.

order: \Theta(1)



### <T>List<U>GetFirst ###

static T * <T>List<U>GetFirst(struct <T>List *const list)



return: A pointer to the first element of _list_.

order: \Theta(1)



### <T>List<U>GetLast ###

static T * <T>List<U>GetLast(struct <T>List *const list)



return: A pointer to the last element of _list_.

order: \Theta(1)



### <T>List<U>Sort ###

static void <T>List<U>Sort(struct <T>List *const list)

Sorts _<U>_, but leaves the other lists in _<T>_ alone. Must have a
 comparator defined for the index.

order: \Omega(_list_.n), O(_list_.n log _list_.n)



### <T>List<U>Compare ###

static int <T>List<U>Compare(const struct <T>List *const alist,
	const struct <T>List *const blist)

Compares two linked-lists as sequences in the order specified by _<U>_.

return: The first comparator that is not equal to zero, or 0 if they are
 equal. Two null pointers are considered equal. Must have a comparator defined
 for this index.

implements: <<T>List>Comparator

order: \Theta(min(_alist_.n, _blist_.n))



### <T>List<U>TakeSubtraction ###

static void <T>List<U>TakeSubtraction(struct <T>List *const list,
	struct <T>List *const a, struct <T>List *const b)

Appends _that_ with _b_ subtracted from _a_ as a sequence in _<U>_. If
 _list_ is null, then it removes elements. Must have _LIST_U[A-D]_COMPARATOR_
 defined.

order: O(_a_.n + _b_.n)



### <T>List<U>TakeUnion ###

static void <T>List<U>TakeUnion(struct <T>List *const list,
	struct <T>List *const a, struct <T>List *const b)

Appends _list_ with the union of _a_ and _b_ as a sequence in _<U>_. Equal
 elements are moved from _a_. If _list_ is null, then it removes elements. Must
 have _LIST_U[A-D]_COMPARATOR_ defined.

order: O(_a_.n + _b_.n)



### <T>List<U>TakeIntersection ###

static void <T>List<U>TakeIntersection(struct <T>List *const list,
	struct <T>List *const a, struct <T>List *const b)

Appends _list_ with the intersection of _a_ and _b_ as a sequence in _<U>_.
 Equal elements are moved from _a_. If _list_ is null, then it removes elements.
 Must have _LIST_U[A-D]_COMPARATOR_ defined.

order: O(_a_.n + _b_.n)



### <T>List<U>TakeXor ###

static void <T>List<U>TakeXor(struct <T>List *const list,
	struct <T>List *const a, struct <T>List *const b)

Appends _list_ with _a_ exclusive-or _b_ as a sequence in _<U>_. Equal
 elements are moved from _a_. If _list_ is null, then it removes elements. Must
 have _LIST_U[A-D]_COMPARATOR_ defined.

order: O(_a_.n + _b_.n)



### <T>List<U>TakeIf ###

static void <T>List<U>TakeIf(struct <T>List *const list,
	struct <T>List *const from, const <T>Predicate predicate)

Appends _list_ with _from_ if _predicate_ is null or true in the order
 specified by _<U>_. If _list_ is null, then it removes elements.

order: ~ \Theta(_list_.n) \times O(_predicate_)



### <T>List<U>BiTakeIf ###

static void <T>List<U>BiTakeIf(struct <T>List *const list,
	struct <T>List *const from, const <T>BiPredicate bipredicate,
	void *const param)

Appends _list_ with _from_ if _bipredicate_ is null or true in the order
 specified by _<U>_. If _list_ is null, then it removes elements.

order: ~ \Theta(_list_.n) \times O(_predicate_)



### <T>List<U>ForEach ###

static void <T>List<U>ForEach(struct <T>List *const list,
	const <T>Action action)

Performs _action_ for each element in the list in the order specified by
 _<U>_. You can tranfer or delete the data, or see `<T>List<U>TakeIf`.

order: ~ \Theta(_list_.n) \times O(_action_)



### <T>List<U>BiForEach ###

static void <T>List<U>BiForEach(struct <T>List *const list,
	const <T>BiAction biaction, void *const param)

Performs _biaction_ for each element in the list in the order specified by
 _<U>_.

order: ~ \Theta(_list_.n) \times O(_action_)

fixme: Untested.



### <T>List<U>ShortCircuit ###

static T * <T>List<U>ShortCircuit(struct <T>List *const list,
	const <T>Predicate predicate)



return: The first _<T>_ in the linked-list, ordered by _<U>_, that causes
 the _predicate_ with _<T>_ as argument to return false, or null if the
 _predicate_ is true for every case. If _list_ or _predicate_ is null, returns
 null.

order: ~ O(_list_.n) \times O(_predicate_)



### <T>List<U>BiShortCircuit ###

static T * <T>List<U>BiShortCircuit(struct <T>List *const list,
	const <T>BiPredicate bipredicate, void *const param)



return: The first _<T>_ in the linked-list, ordered by _<U>_, that
 causes the _bipredicate_ with _<T>_ and _param_ as arguments to return false,
 or null if the _bipredicate_ is true for every case. If _list_ or
 _bipredicate_ is null, returns null.

order: ~ O(_list_.n) \times O(_predicate_)



### <T>List<U>ToString ###

static char * <T>List<U>ToString(const struct <T>List *const list)

Can print 4 things at once before it overwrites. One must set
 _LIST_TO_STRING_ to a function implementing _<T>ToString_ to get this
 functionality.

return: Prints the _list_ in a static buffer.

order: \Theta(1); it has a 255 character limit; every element takes some of it.




